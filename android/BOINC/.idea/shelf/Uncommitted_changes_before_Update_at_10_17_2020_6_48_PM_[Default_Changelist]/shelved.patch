Index: app/src/main/java/edu/berkeley/boinc/client/Monitor.kt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>/*\r\n * This file is part of BOINC.\r\n * http://boinc.berkeley.edu\r\n * Copyright (C) 2020 University of California\r\n *\r\n * BOINC is free software; you can redistribute it and/or modify it\r\n * under the terms of the GNU Lesser General Public License\r\n * as published by the Free Software Foundation,\r\n * either version 3 of the License, or (at your option) any later version.\r\n *\r\n * BOINC is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\r\n * See the GNU Lesser General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU Lesser General Public License\r\n * along with BOINC.  If not, see <http://www.gnu.org/licenses/>.\r\n */\r\npackage edu.berkeley.boinc.client\r\n\r\nimport android.app.Service\r\nimport android.content.BroadcastReceiver\r\nimport android.content.Context\r\nimport android.content.Intent\r\nimport android.content.IntentFilter\r\nimport android.graphics.Bitmap\r\nimport android.net.wifi.SupplicantState\r\nimport android.net.wifi.WifiInfo\r\nimport android.net.wifi.WifiManager\r\nimport android.net.wifi.WifiManager.NETWORK_STATE_CHANGED_ACTION\r\nimport android.os.*\r\nimport android.util.Log\r\nimport androidx.core.content.getSystemService\r\nimport androidx.lifecycle.LifecycleService\r\nimport androidx.lifecycle.lifecycleScope\r\nimport androidx.localbroadcastmanager.content.LocalBroadcastManager\r\nimport androidx.preference.PreferenceManager\r\nimport edu.berkeley.boinc.BOINCApplication\r\nimport edu.berkeley.boinc.BuildConfig\r\nimport edu.berkeley.boinc.R\r\nimport edu.berkeley.boinc.mutex.BoincMutex\r\nimport edu.berkeley.boinc.rpc.*\r\nimport edu.berkeley.boinc.rpc.Message\r\nimport edu.berkeley.boinc.rpcExtern.RpcExternServer\r\nimport edu.berkeley.boinc.rpcExtern.RpcSettingsData\r\nimport edu.berkeley.boinc.utils.*\r\nimport kotlinx.coroutines.coroutineScope\r\nimport kotlinx.coroutines.launch\r\nimport okio.buffer\r\nimport okio.source\r\nimport java.io.File\r\nimport java.io.IOException\r\nimport java.io.InputStreamReader\r\nimport java.util.*\r\nimport javax.inject.Inject\r\nimport kotlin.properties.Delegates\r\n\r\n\r\n/**\r\n * Main Service of BOINC on Android\r\n * - manages life-cycle of the BOINC Client.\r\n * - frequently polls the latest status of the client (e.g. running tasks, attached projects etc)\r\n * - reports device status (e.g. battery level, connected to charger etc) to the client\r\n * - holds singleton of client status data model and applications persistent preferences\r\n */\r\nclass Monitor : LifecycleService() {\r\n    private val abi = if (Build.VERSION.SDK_INT < Build.VERSION_CODES.LOLLIPOP) {\r\n        @Suppress(\"DEPRECATION\")\r\n        Build.CPU_ABI\r\n    } else {\r\n        Build.SUPPORTED_ABIS[0]\r\n    }\r\n\r\n    //hold the status of the app, controlled by AppPreferences\r\n    @Inject\r\n    lateinit var appPreferences: AppPreferences\r\n\r\n    // holds the BOINC mutex, only compute if acquired\r\n    @Inject\r\n    lateinit var mutex: BoincMutex\r\n\r\n    //provides functions for interaction with client via RPC\r\n    @Inject\r\n    lateinit var clientInterface: ClientInterfaceImplementation\r\n\r\n    @Inject\r\n    lateinit var clientNotification: ClientNotification\r\n\r\n    //holds the status of the client as determined by the Monitor\r\n    @Inject\r\n    lateinit var clientStatus: ClientStatus\r\n\r\n    // holds the status of the device, i.e. status information that can only be obtained trough Java APIs\r\n    @Inject\r\n    lateinit var deviceStatus: DeviceStatus\r\n\r\n    @Inject\r\n    lateinit var noticeNotification: NoticeNotification\r\n\r\n    // External RPC\r\n    var mRpcExternServer = RpcExternServer()\r\n\r\n    // XML defined variables, populated in onCreate\r\n    private lateinit var fileNameClient: String\r\n    private lateinit var fileNameCABundle: String\r\n    private lateinit var fileNameClientConfig: String\r\n    lateinit var fileNameGuiAuthentication: String\r\n    private lateinit var fileNameAllProjectsList: String\r\n    lateinit var fileNameNoMedia: String\r\n    lateinit var boincWorkingDir: String\r\n    private lateinit var clientSocketAddress: String\r\n\r\n    private var clientStatusInterval by Delegates.notNull<Int>()\r\n    private var deviceStatusIntervalScreenOff: Int = 0\r\n    private val updateTimer = Timer(true) // schedules frequent client status update\r\n    private val statusUpdateTask: TimerTask = StatusUpdateTimerTask()\r\n    private var updateBroadcastEnabled = false\r\n    private var screenOffStatusOmitCounter = 0\r\n\r\n    // screen on/off updated by screenOnOffBroadcastReceiver\r\n    private var screenOn = false\r\n    private val forceReinstall = false // for debugging purposes //TODO\r\n\r\n    /**\r\n     * Determines BOINC platform name corresponding to device's cpu architecture (ARM, x86).\r\n     * Defaults to ARM\r\n     *\r\n     * @return ID of BOINC platform name string in resources\r\n     */\r\n    val boincPlatform: Int\r\n        get() {\r\n            val platformId: Int\r\n            val arch = System.getProperty(\"os.arch\") ?: \"\"\r\n            val normalizedArch = arch.toUpperCase(Locale.US)\r\n            platformId = when {\r\n                normalizedArch.containsAny(\"ARM64\", \"AARCH64\") -> R.string.boinc_platform_name_arm64\r\n                \"X86_64\" in normalizedArch -> R.string.boinc_platform_name_x86_64\r\n                \"ARM\" in normalizedArch -> R.string.boinc_platform_name_arm\r\n                \"86\" in normalizedArch -> R.string.boinc_platform_name_x86\r\n                else -> {\r\n                    if (Logging.ERROR)\r\n                        Log.w(Logging.TAG, \"could not map os.arch ($arch) to platform, default to arm.\")\r\n                    R.string.boinc_platform_name_arm\r\n                }\r\n            }\r\n            if (Logging.ERROR)\r\n                Log.d(Logging.TAG, \"BOINC platform: ${getString(platformId)} for os.arch: $arch\")\r\n            return platformId\r\n        }\r\n\r\n    /**\r\n     * Determines BOINC alt platform name corresponding to device's cpu architecture (ARM, x86).\r\n     *\r\n     * @return BOINC platform name string in resources\r\n     */\r\n    val boincAltPlatform: String\r\n        get() {\r\n            var platformName = \"\"\r\n            val arch = System.getProperty(\"os.arch\") ?: \"\"\r\n            val normalizedArch = arch.toUpperCase(Locale.US)\r\n            if (normalizedArch.containsAny(\"ARM64\", \"AARCH64\"))\r\n                platformName = getString(R.string.boinc_platform_name_arm)\r\n            else if (\"X86_64\" in normalizedArch)\r\n                platformName = getString(R.string.boinc_platform_name_x86)\r\n            if (Logging.ERROR) Log.d(Logging.TAG, \"BOINC Alt platform: $platformName for os.arch: $arch\")\r\n            return platformName\r\n        }\r\n\r\n    /**\r\n     * Returns path to file in BOINC's working directory that contains GUI authentication key\r\n     *\r\n     * @return absolute path to file holding GUI authentication key\r\n     */\r\n    val authFilePath: String\r\n        get() = boincWorkingDir + fileNameGuiAuthentication\r\n\r\n    override fun onBind(intent: Intent): IBinder? {\r\n        super.onBind(intent)\r\n        if (Logging.DEBUG) Log.d(Logging.TAG, \"Monitor onBind\")\r\n        return mBinder\r\n    }\r\n\r\n    override fun onCreate() {\r\n        (application as BOINCApplication).appComponent.inject(this)\r\n        super.onCreate()\r\n        Log.d(Logging.TAG, \"Monitor onCreate()\")\r\n\r\n        // populate attributes with XML resource values\r\n        boincWorkingDir = getString(R.string.client_path)\r\n        fileNameClient = getString(R.string.client_name)\r\n        fileNameCABundle = getString(R.string.client_cabundle)\r\n        fileNameClientConfig = getString(R.string.client_config)\r\n        fileNameGuiAuthentication = getString(R.string.auth_file_name)\r\n        fileNameAllProjectsList = getString(R.string.all_projects_list)\r\n        fileNameNoMedia = getString(R.string.nomedia)\r\n        clientStatusInterval = resources.getInteger(R.integer.status_update_interval_ms)\r\n        deviceStatusIntervalScreenOff = resources.getInteger(R.integer.device_status_update_screen_off_every_X_loop)\r\n        clientSocketAddress = getString(R.string.client_socket_address)\r\n        if (Logging.ERROR) {\r\n            Log.d(Logging.TAG, \"Monitor onCreate(): singletons initialized\")\r\n        }\r\n\r\n        // set current screen on/off status\r\n        screenOn = getSystemService<PowerManager>()!!.isScreenOnCompat\r\n\r\n        // register screen on/off receiver\r\n        val onFilter = IntentFilter(Intent.ACTION_SCREEN_ON)\r\n        val offFilter = IntentFilter(Intent.ACTION_SCREEN_OFF)\r\n        registerReceiver(screenOnOffReceiver, onFilter)\r\n        registerReceiver(screenOnOffReceiver, offFilter)\r\n\r\n        // rpcExtern register the receiver\r\n        val intentFilter = IntentFilter()\r\n        intentFilter.addAction(NETWORK_STATE_CHANGED_ACTION)\r\n        intentFilter.addAction(\"RPC_EXTERN\")\r\n        registerReceiver(mRpcExternBroadCastReceiver, intentFilter)\r\n//      LocalBroadcastManager.getInstance(this).registerReceiver(mRpcExternBroadCastReceiver,intentFilter)\r\n    }\r\n\r\n    override fun onDestroy() {\r\n        super.onDestroy()\r\n        if (Logging.ERROR) Log.d(Logging.TAG, \"Monitor onDestroy()\")\r\n        updateBroadcastEnabled = false // prevent broadcast from currently running update task\r\n        updateTimer.cancel() // cancel task\r\n\r\n        // there might be still other AsyncTasks executing RPCs\r\n        // close sockets in a synchronized way\r\n        clientInterface.close()\r\n        try {\r\n            // remove screen on/off receiver\r\n            unregisterReceiver(screenOnOffReceiver)\r\n        } catch (e: Exception) {\r\n            if (Logging.ERROR) Log.e(Logging.TAG, \"Monitor.onDestroy error: \", e)\r\n        }\r\n\r\n        // RpcExtern receiver remove\r\n//      LocalBroadcastManager.getInstance(this).unregisterReceiver(mRpcExternBroadCastReceiver)\r\n        unregisterReceiver(mRpcExternBroadCastReceiver)\r\n\r\n        updateBroadcastEnabled = false // prevent broadcast from currently running update task\r\n        updateTimer.cancel() // cancel task\r\n        mutex.release() // release BOINC mutex\r\n\r\n        // release locks, if held.\r\n        try {\r\n            clientStatus.setWakeLock(false)\r\n            clientStatus.setWifiLock(false)\r\n        } catch (e: Exception) {\r\n            if (Logging.ERROR) Log.e(Logging.TAG, \"Monitor.onDestroy error: \", e)\r\n        }\r\n    }\r\n\r\n    override fun onStartCommand(intent: Intent?, flags: Int, startId: Int): Int {\r\n        super.onStartCommand(intent, flags, startId)\r\n        //this gets called after startService(intent) (either by BootReceiver or SplashActivity, depending on the user's autostart configuration)\r\n        if (Logging.ERROR) Log.d(Logging.TAG, \"Monitor onStartCommand()\")\r\n\r\n        // try to acquire BOINC mutex\r\n        // run here in order to recover, if mutex holding app gets closed.\r\n        if (!updateBroadcastEnabled && mutex.acquire()) {\r\n            updateBroadcastEnabled = true\r\n            // register and start update task\r\n            // using .scheduleAtFixedRate() can cause a series of bunched-up runs\r\n            // when previous executions are delayed (e.g. during clientSetup() )\r\n            updateTimer.schedule(statusUpdateTask, 0, clientStatusInterval.toLong())\r\n        }\r\n        if (!mutex.isAcquired && Logging.ERROR) Log.e(Logging.TAG, \"Monitor.onStartCommand: mutex acquisition failed, do not start BOINC.\")\r\n\r\n        // execute action if one is explicitly requested (e.g. from notification)\r\n        if (intent != null) {\r\n            val actionCode = intent.getIntExtra(\"action\", -1)\r\n            if (Logging.DEBUG) Log.d(Logging.TAG, \"Monitor.onStartCommand() with action code: $actionCode\")\r\n            when (actionCode) {\r\n                1 -> lifecycleScope.launch {setClientRunMode(RUN_MODE_NEVER)}\r\n                2 -> lifecycleScope.launch {setClientRunMode(RUN_MODE_AUTO)}\r\n            }\r\n        }\r\n\r\n        /*\r\n         * START_STICKY causes service to stay in memory until stopSelf() is called, even if all\r\n         * Activities get destroyed by the system. Important for GUI keep-alive\r\n         * For detailed service documentation see\r\n         * http://android-developers.blogspot.com.au/2010/02/service-api-changes-starting-with.html\r\n         */\r\n        return Service.START_STICKY\r\n    }\r\n    // --end-- attributes and methods related to Android Service life-cycle\r\n    // public methods for Activities\r\n    /**\r\n     * Force refresh of client status data model, will fire Broadcast upon success.\r\n     */\r\n    fun forceRefresh() {\r\n        if (!mutex.isAcquired) return  // do not try to update if client is not running\r\n        if (Logging.DEBUG) Log.d(Logging.TAG, \"forceRefresh()\")\r\n        try {\r\n            updateTimer.schedule(StatusUpdateTimerTask(), 0)\r\n        } catch (e: Exception) {\r\n            if (Logging.WARNING) Log.w(Logging.TAG, \"Monitor.forceRefresh error: \", e)\r\n        } // throws IllegalStateException if called after timer got cancelled, i.e. after manual shutdown\r\n    }\r\n\r\n    // --end-- public methods for Activities\r\n    // multi-threaded frequent information polling\r\n    /**\r\n     * Task to frequently and asynchronously poll the client's status. Executed in different thread.\r\n     */\r\n    private inner class StatusUpdateTimerTask : TimerTask() {\r\n        override fun run() {\r\n            updateStatus()\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Reports current device status to client and reads current client status.\r\n     * Updates ClientStatus and fires Broadcast.\r\n     * Called frequently to poll current status.\r\n     */\r\n    private fun updateStatus() {\r\n        // check whether RPC client connection is alive\r\n        if (!clientInterface.connectionAlive() && clientSetup()) { // start setup routine\r\n            // interact with client only if connection established successfully\r\n            reportDeviceStatus()\r\n            readClientStatus(true) // read initial data\r\n        }\r\n        if (!screenOn && screenOffStatusOmitCounter < deviceStatusIntervalScreenOff)\r\n            screenOffStatusOmitCounter++ // omit status reporting according to configuration\r\n        else {\r\n            // screen is on, or omit counter reached limit\r\n            if (clientInterface.connectionAlive()) {\r\n                reportDeviceStatus()\r\n                readClientStatus(false) // readClientStatus is also required when screen is off, otherwise no wakeLock acquisition.\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Reads client status via RPCs\r\n     * Optimized to retrieve only subset of information (required to determine wakelock state) if screen is turned off\r\n     *\r\n     * @param forceCompleteUpdate forces update of entire status information, regardless of screen status\r\n     */\r\n    private fun readClientStatus(forceCompleteUpdate: Boolean) {\r\n        try {\r\n            val status: CcStatus? // read independently of screen status\r\n\r\n            // complete status read, depending on screen status\r\n            // screen off: only read computing status to adjust wakelock, do not send broadcast\r\n            // screen on: read complete status, set ClientStatus, send broadcast\r\n            // forceCompleteUpdate: read complete status, independently of screen setting\r\n            if (screenOn || forceCompleteUpdate) {\r\n                // complete status read, with broadcast\r\n                if (Logging.VERBOSE) Log.d(Logging.TAG, \"readClientStatus(): screen on, get complete status\")\r\n                status = clientInterface.ccStatus\r\n                val state = clientInterface.state\r\n                val transfers = clientInterface.fileTransfers\r\n                val acctMgrInfo = clientInterface.acctMgrInfo\r\n                val newNotices = clientInterface.getNotices(clientStatus.mostRecentNoticeSeqNo)\r\n                if (allNotNull(status, state, state?.hostInfo, acctMgrInfo)) {\r\n                    clientStatus.setClientStatus(status, state.results, state.projects,\r\n                            transfers, state.hostInfo, acctMgrInfo,\r\n                            newNotices)\r\n                } else {\r\n                    var nullValues = \"\"\r\n                    if (state == null) {\r\n                        nullValues += \"state \"\r\n                    } else {\r\n                        if (state.hostInfo == null) nullValues += \"state.host_info \"\r\n                    }\r\n                    if (transfers == null) nullValues += \"transfers \"\r\n                    if (acctMgrInfo == null) nullValues += \"acctMgrInfo \"\r\n                    if (Logging.ERROR) Log.e(Logging.TAG, \"readClientStatus(): connection problem, null: $nullValues\")\r\n                }\r\n\r\n                // update notices notification\r\n                noticeNotification.update(clientStatus.rssNotices, appPreferences.showNotificationForNotices)\r\n\r\n                // check whether monitor is still intended to update, if not, skip broadcast and exit...\r\n                if (updateBroadcastEnabled) {\r\n                    applicationContext.sendBroadcast(Intent().apply {action = \"edu.berkeley.boinc.clientstatus\"})\r\n                }\r\n            } else {\r\n                // read only ccStatus to adjust wakelocks and service state independently of screen status\r\n                status = clientInterface.ccStatus\r\n            }\r\n            if (BuildConfig.DEBUG && status == null) {\r\n                error(\"Assertion failed\")\r\n            }\r\n            val computing = (status.taskSuspendReason == SUSPEND_NOT_SUSPENDED\r\n                    || status.taskSuspendReason == SUSPEND_REASON_CPU_THROTTLE)\r\n            if (Logging.VERBOSE) Log.d(Logging.TAG, \"readClientStatus(): computation enabled: $computing\")\r\n            clientStatus.setWifiLock(computing)\r\n            clientStatus.setWakeLock(computing)\r\n            clientNotification.update(clientStatus, this, computing)\r\n        } catch (e: Exception) {\r\n            if (Logging.ERROR)\r\n                Log.e(Logging.TAG, \"Monitor.readClientStatus exception: \" + e.message, e)\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Reports current device status to the client via RPC\r\n     * BOINC client uses this data to enforce preferences, e.g. suspend battery but requires information only/best available through Java API calls.\r\n     */\r\n    private fun reportDeviceStatus() {\r\n        if (Logging.VERBOSE) Log.d(Logging.TAG, \"reportDeviceStatus()\")\r\n        try {\r\n            // set devices status\r\n            // make sure deviceStatus is initialized\r\n            val reportStatusSuccess = clientInterface.reportDeviceStatus(deviceStatus.update(screenOn)) // transmit device status via rpc\r\n            if (reportStatusSuccess)\r\n                screenOffStatusOmitCounter = 0\r\n            else if (Logging.DEBUG)\r\n                Log.d(Logging.TAG, \"reporting device status returned false.\")\r\n        } catch (e: Exception) {\r\n            if (Logging.ERROR) Log.e(Logging.TAG, \"Monitor.reportDeviceStatus excpetion: \" + e.message)\r\n        }\r\n    }\r\n    // --end-- multi-threaded frequent information polling\r\n\r\n    // BOINC client installation and run-time management\r\n    /**\r\n     * installs client binaries(if changed) and other required files\r\n     * executes client process\r\n     * triggers initial reads (e.g. preferences, project list etc)\r\n     *\r\n     * @return Boolean whether connection established successfully\r\n     */\r\n    private fun clientSetup(): Boolean {\r\n        if (Logging.ERROR) Log.d(Logging.TAG, \"Monitor.clientSetup()\")\r\n        clientStatus.setSetupStatus(ClientStatus.SETUP_STATUS_LAUNCHING, true)\r\n        val clientProcessName = boincWorkingDir + fileNameClient\r\n        val md5AssetClient = computeMd5(fileNameClient, true)\r\n        val md5InstalledClient = computeMd5(clientProcessName, false)\r\n\r\n        // If client hashes do not match, we need to install the one that is a part\r\n        // of the package. Shutdown the currently running client if needed.\r\n        //\r\n        if (forceReinstall || md5InstalledClient != md5AssetClient) {\r\n            if (Logging.DEBUG) Log.d(Logging.TAG, \"Hashes of installed client does not match binary in assets - re-install.\")\r\n\r\n            // try graceful shutdown using RPC (faster)\r\n            if (getPidForProcessName(clientProcessName) != null && connectClient()) {\r\n                clientInterface.quit()\r\n                val attempts = applicationContext.resources.getInteger(R.integer.shutdown_graceful_rpc_check_attempts)\r\n                val sleepPeriod = applicationContext.resources.getInteger(R.integer.shutdown_graceful_rpc_check_rate_ms)\r\n                var x = 0\r\n                while (x < attempts) {\r\n                    Thread.sleep(sleepPeriod.toLong())\r\n                    if (getPidForProcessName(clientProcessName) == null) { //client is now closed\r\n                        if (Logging.DEBUG) {\r\n                            Log.d(Logging.TAG,\r\n                                    \"quitClient: gracefull RPC shutdown successful after \" + x +\r\n                                            \" seconds\")\r\n                        }\r\n                        x = attempts\r\n                    }\r\n                    x++\r\n                }\r\n            }\r\n\r\n            // quit with OS signals\r\n            if (getPidForProcessName(clientProcessName) != null) {\r\n                quitProcessOsLevel(clientProcessName)\r\n            }\r\n\r\n            // at this point client is definitely not running. install new binary...\r\n            if (!installClient()) {\r\n                if (Logging.ERROR) Log.w(Logging.TAG, \"BOINC client installation failed!\")\r\n                return false\r\n            }\r\n        }\r\n\r\n        // Start the BOINC client if we need to.\r\n        val clientPid = getPidForProcessName(clientProcessName)\r\n        if (clientPid == null) {\r\n            if (Logging.ERROR) Log.d(Logging.TAG, \"Starting the BOINC client\")\r\n            if (!runClient()) {\r\n                if (Logging.ERROR) Log.d(Logging.TAG, \"BOINC client failed to start\")\r\n                return false\r\n            }\r\n        }\r\n\r\n        // Try to connect to executed Client in loop\r\n        //\r\n        val retryRate = resources.getInteger(R.integer.monitor_setup_connection_retry_rate_ms)\r\n        val retryAttempts = resources.getInteger(R.integer.monitor_setup_connection_retry_attempts)\r\n        var connected = false\r\n        var counter = 0\r\n        while (!connected && counter < retryAttempts) {\r\n            if (Logging.DEBUG) Log.d(Logging.TAG, \"Attempting BOINC client connection...\")\r\n            connected = connectClient()\r\n            counter++\r\n            Thread.sleep(retryRate.toLong())\r\n        }\r\n        var init = false\r\n        if (connected) { // connection established\r\n            try {\r\n                // read preferences for GUI to be able to display data\r\n                val clientPrefs = clientInterface.globalPrefsWorkingStruct!!\r\n                clientStatus.prefs = clientPrefs\r\n\r\n                // set Android model as hostinfo\r\n                // should output something like \"Samsung Galaxy SII - SDK:15 ABI:armeabi-v7a\"\r\n                val model = \"${Build.MANUFACTURER} ${Build.MODEL} - SDK: ${Build.VERSION.SDK_INT} ABI: $abi\"\r\n                val version = Build.VERSION.RELEASE\r\n                if (Logging.ERROR) {\r\n                    Log.d(Logging.TAG, \"reporting hostinfo model name: $model\")\r\n                    Log.d(Logging.TAG, \"reporting hostinfo os name: Android\")\r\n                    Log.d(Logging.TAG, \"reporting hostinfo os version: $version\")\r\n                }\r\n                clientInterface.setHostInfo(model, version)\r\n                init = true\r\n            } catch (e: Exception) {\r\n                if (Logging.ERROR) Log.e(Logging.TAG, \"Monitor.clientSetup() init failed: \" + e.message)\r\n            }\r\n        }\r\n        if (init) {\r\n            if (Logging.ERROR) Log.d(Logging.TAG, \"Monitor.clientSetup() - setup completed successfully\")\r\n            clientStatus.setSetupStatus(ClientStatus.SETUP_STATUS_AVAILABLE, false)\r\n\r\n            if (Logging.DEBUG) Log.d(Logging.TAG, \"Start RpcExtern\")\r\n            try {\r\n                val wiFi = isconnectedToWifi()\r\n                val rpcSettingsData = getPreferences() // a change breaks start and returns here\r\n                mRpcExternServer.start(wiFi, this, clientSocketAddress, rpcSettingsData)\r\n                if (Logging.DEBUG) Log.e(Logging.TAG, \"Start RpcExtern starting\")\r\n            } catch (e: Exception) {\r\n                if (Logging.DEBUG) Log.e(Logging.TAG, \"Start RpcExtern something went wrong\")\r\n            }\r\n        } else {\r\n            if (Logging.ERROR) Log.e(Logging.TAG, \"Monitor.clientSetup() - setup experienced an error\")\r\n            clientStatus.setSetupStatus(ClientStatus.SETUP_STATUS_ERROR, true)\r\n        }\r\n        return connected\r\n    }\r\n\r\n    // use this function to connect the debugger to the service\r\n    // click on attach Debugger to Android process\r\n    // and wait for remote to show up, click on it -> OK and you are set.\r\n    // this must be done within the wait cycle.\r\n    fun waitForDebugger() {\r\n        var wait = 5\r\n        while (wait > 1) {\r\n            Thread.sleep(1000)\r\n            wait -= 1\r\n        }\r\n    }\r\n\r\n    // get RpcExternal, External GUI Settings\r\n    private fun getPreferences(): RpcSettingsData {\r\n//        waitForDebugger()\r\n        val settingsData = RpcSettingsData()\r\n        try {\r\n//            val preferences = applicationContext.getSharedPreferences(\"rpcExtern\", Context.MODE_PRIVATE);\r\n            val preferences = PreferenceManager.getDefaultSharedPreferences(this)\r\n            val externEnabled = preferences.getBoolean(\"rpcExternEnable\", false)\r\n            val externEncryption = preferences.getBoolean(\"rpcExternEncryption\", true)\r\n            val externPassword: String = preferences.getString(\"rpcExternPasswrd\", \"\").toString()\r\n            val externPort: String = preferences.getString(\"rpcExternPort\", \"31416\").toString()\r\n            val externAllowIp1 = preferences.getString(\"rpcExternAllowIp1\", \"\")!!\r\n            val externAllowIp2 = preferences.getString(\"rpcExternAllowIp2\", \"\")!!\r\n            val externAllowIp3 = preferences.getString(\"rpcExternAllowIp3\", \"\")!!\r\n            val externAllowIp4 = preferences.getString(\"rpcExternAllowIp4\", \"\")!!\r\n\r\n            settingsData.set(externEnabled, externEncryption, externPassword, externPort, externAllowIp1, externAllowIp2, externAllowIp3, externAllowIp4)\r\n        } catch (e: Exception) {\r\n            if (Logging.DEBUG) Log.e(Logging.TAG, \"RpcExtern failed getPreferences\")\r\n        }\r\n        return settingsData\r\n    }\r\n\r\n    /**\r\n     * Executes BOINC client.\r\n     * Using Java Runtime exec method\r\n     *\r\n     * @return Boolean success\r\n     */\r\n    private fun runClient(): Boolean {\r\n        var success = false\r\n        try {\r\n            val cmd = arrayOf(boincWorkingDir + fileNameClient, \"--daemon\", \"--gui_rpc_unix_domain\")\r\n            if (Logging.ERROR) Log.w(Logging.TAG, \"Launching '${cmd[0]}' from '$boincWorkingDir'\")\r\n            Runtime.getRuntime().exec(cmd, null, File(boincWorkingDir))\r\n            success = true\r\n        } catch (e: IOException) {\r\n            if (Logging.ERROR) {\r\n                Log.d(Logging.TAG, \"Starting BOINC client failed with exception: \" + e.message)\r\n                Log.e(Logging.TAG, \"IOException\", e)\r\n            }\r\n        }\r\n        return success\r\n    }\r\n\r\n    /**\r\n     * Establishes connection to client and handles initial authentication\r\n     *\r\n     * @return Boolean success\r\n     */\r\n    private fun connectClient(): Boolean {\r\n        var success = clientInterface.open(clientSocketAddress)\r\n        if (!success) {\r\n            if (Logging.ERROR) Log.e(Logging.TAG, \"Connection failed!\")\r\n            return false\r\n        }\r\n\r\n        //authorize\r\n        success = clientInterface.authorizeGuiFromFile(boincWorkingDir + fileNameGuiAuthentication)\r\n        if (!success && Logging.ERROR) {\r\n            Log.e(Logging.TAG, \"Authorization failed!\")\r\n        }\r\n        return success\r\n    }\r\n\r\n    /**\r\n     * Installs required files from APK's asset directory to the applications' internal storage.\r\n     * File attributes override and executable are defined here\r\n     *\r\n     * @return Boolean success\r\n     */\r\n    private fun installClient(): Boolean {\r\n        if (!installFile(fileNameClient, true, \"\")) {\r\n            if (Logging.ERROR) Log.d(Logging.TAG, INSTALL_FAILED + fileNameClient)\r\n            return false\r\n        }\r\n        if (!installFile(fileNameCABundle, false, \"\")) {\r\n            if (Logging.ERROR) Log.d(Logging.TAG, INSTALL_FAILED + fileNameCABundle)\r\n            return false\r\n        }\r\n        if (!installFile(fileNameClientConfig, false, \"\")) {\r\n            if (Logging.ERROR) Log.d(Logging.TAG, INSTALL_FAILED + fileNameClientConfig)\r\n            return false\r\n        }\r\n        if (!installFile(fileNameAllProjectsList, false, \"\")) {\r\n            if (Logging.ERROR) Log.d(Logging.TAG, INSTALL_FAILED + fileNameAllProjectsList)\r\n            return false\r\n        }\r\n        if (!installFile(fileNameNoMedia, false, \".$fileNameNoMedia\")) {\r\n            if (Logging.ERROR) Log.d(Logging.TAG, INSTALL_FAILED + fileNameNoMedia)\r\n            return false\r\n        }\r\n        return true\r\n    }\r\n\r\n    /**\r\n     * Copies given file from APK assets to internal storage.\r\n     *\r\n     * @param file       name of file as it appears in assets directory\r\n     * @param executable set executable flag of file in internal storage\r\n     * @param targetFile name of target file\r\n     * @return Boolean success\r\n     */\r\n    private fun installFile(file: String, executable: Boolean, targetFile: String): Boolean {\r\n        var success = false\r\n\r\n        // If file is executable, cpu architecture has to be evaluated\r\n        // and assets directory select accordingly\r\n        val source = if (executable) assetsDirForCpuArchitecture + file else file\r\n        val target = if (targetFile.isNotEmpty()) {\r\n            File(boincWorkingDir + targetFile)\r\n        } else {\r\n            File(boincWorkingDir + file)\r\n        }\r\n        try {\r\n            // Copy file from the asset manager to clientPath\r\n            applicationContext.assets.open(source).copyToFile(target)\r\n            success = true //copy succeeded without exception\r\n\r\n            // Set executable, if requested\r\n            if (executable) {\r\n                success = target.setExecutable(true) // return false, if not executable\r\n            }\r\n            if (Logging.ERROR) Log.d(Logging.TAG, \"Installation of \" + source + \" successful. Executable: \" +\r\n                    executable + \"/\" + success)\r\n        } catch (ioe: IOException) {\r\n            if (Logging.ERROR) {\r\n                Log.e(Logging.TAG, IOEXCEPTION_LOG + ioe.message)\r\n                Log.d(Logging.TAG, \"Install of $source failed.\")\r\n            }\r\n        }\r\n        return success\r\n    }\r\n\r\n    /**\r\n     * Determines assets directory (contains BOINC client binaries) corresponding to device's cpu architecture (ARM, x86)\r\n     *\r\n     * @return name of assets directory for given platform, not an absolute path.\r\n     */\r\n    private val assetsDirForCpuArchitecture: String\r\n        get() {\r\n            var archAssetsDirectory = \"\"\r\n            when (boincPlatform) {\r\n                R.string.boinc_platform_name_arm -> archAssetsDirectory = getString(R.string.assets_dir_arm)\r\n                R.string.boinc_platform_name_arm64 -> archAssetsDirectory = getString(R.string.assets_dir_arm64)\r\n                R.string.boinc_platform_name_x86 -> archAssetsDirectory = getString(R.string.assets_dir_x86)\r\n                R.string.boinc_platform_name_x86_64 -> archAssetsDirectory = getString(R.string.assets_dir_x86_64)\r\n                else -> {\r\n                }\r\n            }\r\n            return archAssetsDirectory\r\n        }\r\n\r\n    /**\r\n     * Computes MD5 hash of requested file\r\n     *\r\n     * @param fileName absolute path or name of file in assets directory, see inAssets parameter\r\n     * @param inAssets if true, fileName is file name in assets directory, if not, absolute path\r\n     * @return md5 hash of file\r\n     */\r\n    private fun computeMd5(fileName: String, inAssets: Boolean): String {\r\n        try {\r\n            val source = if (inAssets) {\r\n                applicationContext.assets.open(assetsDirForCpuArchitecture + fileName).source()\r\n            } else {\r\n                File(fileName).source()\r\n            }.buffer()\r\n            val md5 = source.readByteString().md5().hex()\r\n            source.close()\r\n            return md5\r\n        } catch (e: IOException) {\r\n            if (Logging.ERROR) Log.e(Logging.TAG, IOEXCEPTION_LOG + e.message)\r\n        }\r\n        return \"\"\r\n    }\r\n\r\n    /**\r\n     * Determines ProcessID corresponding to given process name\r\n     *\r\n     * @param processName name of process, according to output of \"ps\"\r\n     * @return process id, according to output of \"ps\"\r\n     */\r\n    private fun getPidForProcessName(processName: String): Int? {\r\n        val processLines: List<String>\r\n\r\n        //run ps and read output\r\n        try {\r\n            val p = Runtime.getRuntime().exec(\"ps\")\r\n            p.waitFor()\r\n            val isr = InputStreamReader(p.inputStream)\r\n            processLines = isr.readLines()\r\n            isr.close()\r\n        } catch (e: Exception) {\r\n            if (Logging.ERROR) Log.e(Logging.TAG, \"Exception: \" + e.message)\r\n            return null\r\n        }\r\n        if (processLines.size < 2) {\r\n            if (Logging.ERROR)\r\n                Log.e(Logging.TAG, \"getPidForProcessName(): ps output has less than 2 lines, failure!\")\r\n            return null\r\n        }\r\n\r\n        // figure out what index PID has\r\n        val headers = processLines[0].split(\"[\\\\s]+\".toRegex()).toTypedArray()\r\n        val pidIndex = headers.indexOfFirst { it == \"PID\" }\r\n        if (pidIndex == -1) {\r\n            return null\r\n        }\r\n        if (Logging.DEBUG)\r\n            Log.d(Logging.TAG, \"getPidForProcessName(): PID at index: $pidIndex for output:\" +\r\n                    \" ${processLines[0]}\")\r\n        var pid: Int? = null\r\n        for (y in 1 until processLines.size) {\r\n            var found = false\r\n            val comps = processLines[y].split(\"[\\\\s]+\".toRegex()).toTypedArray()\r\n            for (arg in comps) {\r\n                if (arg == processName) {\r\n                    if (Logging.DEBUG)\r\n                        Log.d(Logging.TAG, \"getPidForProcessName(): $processName found in line: $y\")\r\n                    found = true\r\n                    break // Break out of inner foreach (comps) loop\r\n                }\r\n            }\r\n            if (found) {\r\n                try {\r\n                    pid = comps[pidIndex].toInt()\r\n                    if (Logging.ERROR)\r\n                        Log.d(Logging.TAG, \"getPidForProcessName(): pid: $pid\")\r\n                } catch (e: NumberFormatException) {\r\n                    if (Logging.ERROR)\r\n                        Log.e(Logging.TAG, \"getPidForProcessName(): NumberFormatException for \"\r\n                                + \"${comps[pidIndex]} at index: $pidIndex\")\r\n                }\r\n                break // Break out of outer for (processLinesAr) loop\r\n            }\r\n        }\r\n        // if not happen in ps output, not running?!\r\n        if (pid == null && Logging.ERROR)\r\n            Log.d(Logging.TAG, \"getPidForProcessName(): $processName not found in ps output!\")\r\n\r\n        // Find required pid\r\n        return pid\r\n    }\r\n\r\n    /**\r\n     * Exits a process by sending it Linux SIGQUIT and SIGKILL signals\r\n     *\r\n     * @param processName name of process to be killed, according to output of \"ps\"\r\n     */\r\n    private fun quitProcessOsLevel(processName: String) {\r\n        var clientPid = getPidForProcessName(processName)\r\n\r\n        // client PID could not be read, client already ended / not yet started?\r\n        if (clientPid == null) {\r\n            if (Logging.ERROR)\r\n                Log.d(Logging.TAG, \"quitProcessOsLevel could not find PID, already ended or not\" +\r\n                        \" yet started?\")\r\n            return\r\n        }\r\n        if (Logging.DEBUG)\r\n            Log.d(Logging.TAG, \"quitProcessOsLevel for $processName, pid: $clientPid\")\r\n\r\n        // Do not just kill the client on the first attempt.  That leaves dangling\r\n        // science applications running which causes repeated spawning of applications.\r\n        // Neither the UI or client are happy and each are trying to recover from the\r\n        // situation.  Instead send SIGQUIT and give the client time to clean up.\r\n        Process.sendSignal(clientPid, Process.SIGNAL_QUIT)\r\n\r\n        // Wait for the client to shutdown gracefully\r\n        val attempts = applicationContext.resources.getInteger(R.integer.shutdown_graceful_os_check_attempts)\r\n        val sleepPeriod = applicationContext.resources.getInteger(R.integer.shutdown_graceful_os_check_rate_ms)\r\n        var x = 0\r\n        while (x < attempts) {\r\n            Thread.sleep(sleepPeriod.toLong())\r\n            if (getPidForProcessName(processName) == null) { //client is now closed\r\n                if (Logging.DEBUG)\r\n                    Log.d(Logging.TAG, \"quitClient: graceful SIGQUIT shutdown successful after\" +\r\n                            \" $x seconds\")\r\n                x = attempts\r\n            }\r\n            x++\r\n        }\r\n        clientPid = getPidForProcessName(processName)\r\n        if (clientPid != null) {\r\n            // Process is still alive, send SIGKILL\r\n            if (Logging.ERROR) Log.w(Logging.TAG, \"SIGQUIT failed. SIGKILL pid: $clientPid\")\r\n            Process.killProcess(clientPid)\r\n        }\r\n        clientPid = getPidForProcessName(processName)\r\n        if (clientPid != null && Logging.ERROR) {\r\n            Log.w(Logging.TAG, \"SIGKILL failed. still living pid: $clientPid\")\r\n        }\r\n    }\r\n    // --end-- BOINC client installation and run-time management\r\n\r\n    /**\r\n     * broadcast receiver to detect changes to screen on or off, used to adapt scheduling of StatusUpdateTimerTask\r\n     * e.g. avoid polling GUI status RPCs while screen is off in order to save battery\r\n     */\r\n    private var screenOnOffReceiver: BroadcastReceiver = object : BroadcastReceiver() {\r\n        override fun onReceive(context: Context, intent: Intent) {\r\n            val action = intent.action\r\n            if (action == Intent.ACTION_SCREEN_OFF) {\r\n                screenOn = false\r\n                // forces report of device status at next scheduled update\r\n                // allows timely reaction to screen off for resume of computation\r\n                screenOffStatusOmitCounter = deviceStatusIntervalScreenOff\r\n                if (Logging.DEBUG)\r\n                    Log.d(Logging.TAG, \"screenOnOffReceiver: screen turned off\")\r\n            }\r\n            if (action == Intent.ACTION_SCREEN_ON) {\r\n                screenOn = true\r\n                if (Logging.DEBUG)\r\n                    Log.d(Logging.TAG, \"screenOnOffReceiver: screen turned on, force data refresh...\")\r\n                forceRefresh()\r\n            }\r\n        }\r\n    }\r\n\r\n    // RpcExtern\r\n //   val mRpcExternBroadCastReceiver = object : BroadcastReceiver() {\r\n\r\n        private val mRpcExternBroadCastReceiver = RpcExternBroadcastReceiver()\r\n        inner class RpcExternBroadcastReceiver : BroadcastReceiver() {\r\n        override fun onReceive(contxt: Context?, intent: Intent?) {\r\n            try {\r\n                val action : String = intent!!.action.toString()\r\n                if (action.equals(\"RPC_EXTERN\")) {\r\n                    if (intent.hasExtra(\"ENABLED\")) {\r\n                        val rpcSettingsData = RpcSettingsData()\r\n                        val enabled : Boolean = intent.getBooleanExtra(\"ENABLED\", false)\r\n                        val encryption : Boolean = intent.getBooleanExtra(\"ENCRYPTION\", true)\r\n                        val passwrd : String  = intent.getStringExtra(\"PASSWRD\")!!\r\n                        val port : String  = intent.getStringExtra(\"PORT\")!!\r\n                        val ip1 : String  = intent.getStringExtra(\"IP1\")!!\r\n                        val ip2 : String  = intent.getStringExtra(\"IP2\")!!\r\n                        val ip3 : String  = intent.getStringExtra(\"IP3\")!!\r\n                        val ip4 : String  = intent.getStringExtra(\"IP4\")!!\r\n                        rpcSettingsData.set(enabled, encryption, passwrd, port, ip1, ip2, ip3, ip4)\r\n                        val wiFi = isconnectedToWifi()\r\n                        mRpcExternServer.update(wiFi, rpcSettingsData)\r\n                    }\r\n                    if (intent.hasExtra(\"STRING\")) {\r\n                        val data: String = intent.getStringExtra(\"STRING\")!!\r\n                        mRpcExternServer.command(data)\r\n                    }\r\n                }\r\n                if (action.equals(NETWORK_STATE_CHANGED_ACTION))    //Interesting, a lot of API changes but this seems to work\r\n                {\r\n                    val wiFi = isconnectedToWifi()\r\n                    // not sure why we need a delay, maybe the Broadcast needs it\r\n                    // but if we don't, rapidly switching the WiFi on / off doesn't work\r\n                    Thread.sleep(100)\r\n                    mRpcExternServer.update(wiFi, null)\r\n                }\r\n            } catch (e: Exception) {\r\n                var i = 1\r\n                i += 1\r\n            }\r\n        }\r\n    }\r\n\r\n    fun isconnectedToWifi () : Int\r\n    {\r\n        try {\r\n            val wifiManager = this.getSystemService(WIFI_SERVICE) as WifiManager\r\n            val wifiInfo: WifiInfo = wifiManager.getConnectionInfo()\r\n            val ip = wifiInfo.ipAddress\r\n            return ip\r\n        } catch (e: Exception)\r\n        {\r\n        }\r\n        return 0\r\n    }\r\n\r\n    /*\r\n    // eFMer this seems to work, but I can't check it on older Android versions\r\n    fun isconnectedToWifi(): Boolean {\r\n        try {\r\n        val connectivityManager = getSystemService(CONNECTIVITY_SERVICE) as ConnectivityManager\r\n                ?: return false\r\n        return if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.M) {\r\n            val network: Network = connectivityManager.activeNetwork\r\n            val capabilities = connectivityManager.getNetworkCapabilities(network) ?: return false\r\n            capabilities.hasTransport(NetworkCapabilities.TRANSPORT_WIFI)\r\n        } else {\r\n            val networkInfo = connectivityManager.getNetworkInfo(ConnectivityManager.TYPE_WIFI)\r\n                    ?: return false\r\n            networkInfo.isConnected\r\n        }\r\n        } catch (e: Exception)\r\n        {\r\n            return false\r\n        }\r\n    }\r\n    */\r\n\r\n    private suspend fun setClientRunMode(runMode: Int) = coroutineScope {\r\n        try {\r\n            mBinder.setRunMode(runMode)\r\n        } catch (e: RemoteException) {\r\n            if (Logging.ERROR)\r\n                Log.e(Logging.TAG, \"setClientRunMode() error: \", e)\r\n        }\r\n        return@coroutineScope\r\n    }\r\n\r\n    // remote service\r\n    val mBinder: IMonitor.Stub = object : IMonitor.Stub() {\r\n        @Throws(RemoteException::class)\r\n        override fun transferOperation(list: List<Transfer>, op: Int): Boolean {\r\n            return clientInterface.transferOperation(list, op)\r\n        }\r\n\r\n        @Throws(RemoteException::class)\r\n        override fun synchronizeAcctMgr(url: String): Boolean {\r\n            return clientInterface.synchronizeAcctMgr(url)\r\n        }\r\n\r\n        @Throws(RemoteException::class)\r\n        override fun setRunMode(mode: Int): Boolean {\r\n            return clientInterface.setRunMode(mode)\r\n        }\r\n\r\n        @Throws(RemoteException::class)\r\n        override fun setNetworkMode(mode: Int): Boolean {\r\n            return clientInterface.setNetworkMode(mode)\r\n        }\r\n\r\n        @Throws(RemoteException::class)\r\n        override fun setGlobalPreferences(pref: GlobalPreferences): Boolean {\r\n            return clientInterface.setGlobalPreferences(pref)\r\n        }\r\n\r\n        @Throws(RemoteException::class)\r\n        override fun setCcConfig(config: String): Boolean {\r\n            return clientInterface.setCcConfig(config)\r\n        }\r\n\r\n        @Throws(RemoteException::class)\r\n        override fun setDomainName(deviceName: String): Boolean {\r\n            return clientInterface.setDomainName(deviceName)\r\n        }\r\n\r\n        @Throws(RemoteException::class)\r\n        override fun resultOp(op: Int, url: String, name: String): Boolean {\r\n            return clientInterface.resultOp(op, url, name)\r\n        }\r\n\r\n        @Throws(RemoteException::class)\r\n        override fun readAuthToken(path: String): String {\r\n            return clientInterface.readAuthToken(path)\r\n        }\r\n\r\n        @Throws(RemoteException::class)\r\n        override fun projectOp(status: Int, url: String): Boolean {\r\n            return clientInterface.projectOp(status, url)\r\n        }\r\n\r\n        @Throws(RemoteException::class)\r\n        override fun getBoincPlatform(): Int {\r\n            return this@Monitor.boincPlatform\r\n        }\r\n\r\n        @Throws(RemoteException::class)\r\n        override fun lookupCredentials(credentials: AccountIn): AccountOut {\r\n            return clientInterface.lookupCredentials(credentials)\r\n        }\r\n\r\n        @Throws(RemoteException::class)\r\n        override fun isStationaryDeviceSuspected(): Boolean {\r\n            try {\r\n                return deviceStatus.isStationaryDeviceSuspected\r\n            } catch (e: Exception) {\r\n                if (Logging.ERROR) Log.e(Logging.TAG, \"Monitor.IMonitor.Stub: isStationaryDeviceSuspected() error: \", e)\r\n            }\r\n            return false\r\n        }\r\n\r\n        @Throws(RemoteException::class)\r\n        override fun getServerNotices(): List<Notice> {\r\n            return clientStatus.serverNotices\r\n        }\r\n\r\n        @Throws(RemoteException::class)\r\n        override fun getProjectConfigPolling(url: String): ProjectConfig {\r\n            return clientInterface.getProjectConfigPolling(url)\r\n        }\r\n\r\n        @Throws(RemoteException::class)\r\n        override fun getNotices(seq: Int): List<Notice> {\r\n            return clientInterface.getNotices(seq)\r\n        }\r\n\r\n        @Throws(RemoteException::class)\r\n        override fun getMessages(seq: Int): List<Message> {\r\n            return clientInterface.getMessages(seq)\r\n        }\r\n\r\n        @Throws(RemoteException::class)\r\n        override fun getEventLogMessages(seq: Int, num: Int): List<Message> {\r\n            return clientInterface.getEventLogMessages(seq, num)\r\n        }\r\n\r\n        @Throws(RemoteException::class)\r\n        override fun getBatteryChargeStatus(): Int {\r\n            try {\r\n                return deviceStatus.status.batteryChargePct\r\n            } catch (e: Exception) {\r\n                if (Logging.ERROR) Log.e(Logging.TAG, \"Monitor.IMonitor.Stub: getBatteryChargeStatus() error: \", e)\r\n            }\r\n            return 0\r\n        }\r\n\r\n        @Throws(RemoteException::class)\r\n        override fun getAcctMgrInfo(): AcctMgrInfo {\r\n            return clientInterface.acctMgrInfo\r\n        }\r\n\r\n        @Throws(RemoteException::class)\r\n        override fun forceRefresh() {\r\n            this@Monitor.forceRefresh()\r\n        }\r\n\r\n        @Throws(RemoteException::class)\r\n        override fun createAccountPolling(information: AccountIn): AccountOut {\r\n            return clientInterface.createAccountPolling(information)\r\n        }\r\n\r\n        @Throws(RemoteException::class)\r\n        override fun checkProjectAttached(url: String): Boolean {\r\n            return clientInterface.checkProjectAttached(url)\r\n        }\r\n\r\n        @Throws(RemoteException::class)\r\n        override fun attachProject(url: String, projectName: String, authenticator: String): Boolean {\r\n            return clientInterface.attachProject(url, projectName, authenticator)\r\n        }\r\n\r\n        override fun addAcctMgrErrorNum(url: String, userName: String, pwd: String): ErrorCodeDescription {\r\n            val acctMgr = clientInterface.addAcctMgr(url, userName, pwd)\r\n            return if (acctMgr != null) {\r\n                ErrorCodeDescription(acctMgr.errorNum,\r\n                        if (acctMgr.messages.isEmpty()) \"\" else acctMgr.messages.toString())\r\n            } else ErrorCodeDescription(-1)\r\n        }\r\n\r\n        @Throws(RemoteException::class)\r\n        override fun getAuthFilePath(): String {\r\n            return this@Monitor.authFilePath\r\n        }\r\n\r\n        @Throws(RemoteException::class)\r\n        override fun getAttachableProjects(): List<ProjectInfo> {\r\n            return clientInterface.getAttachableProjects(getString(boincPlatform), boincAltPlatform)\r\n        }\r\n\r\n        @Throws(RemoteException::class)\r\n        override fun getAccountManagers(): List<AccountManager> {\r\n            return clientInterface.accountManagers\r\n        }\r\n\r\n        @Throws(RemoteException::class)\r\n        override fun getAcctMgrInfoPresent(): Boolean {\r\n            return clientStatus.acctMgrInfo.isPresent\r\n        }\r\n\r\n        @Throws(RemoteException::class)\r\n        override fun getSetupStatus(): Int {\r\n            return clientStatus.setupStatus\r\n        }\r\n\r\n        @Throws(RemoteException::class)\r\n        override fun getComputingStatus(): Int {\r\n            return clientStatus.computingStatus\r\n        }\r\n\r\n        @Throws(RemoteException::class)\r\n        override fun getComputingSuspendReason(): Int {\r\n            return clientStatus.computingSuspendReason\r\n        }\r\n\r\n        @Throws(RemoteException::class)\r\n        override fun getNetworkSuspendReason(): Int {\r\n            return clientStatus.networkSuspendReason\r\n        }\r\n\r\n        @Throws(RemoteException::class)\r\n        override fun getHostInfo(): HostInfo {\r\n            return clientStatus.hostInfo\r\n        }\r\n\r\n        @Throws(RemoteException::class)\r\n        override fun getPrefs(): GlobalPreferences {\r\n            return clientStatus.prefs\r\n        }\r\n\r\n        @Throws(RemoteException::class)\r\n        override fun getProjects(): List<Project> {\r\n            return clientStatus.projects\r\n        }\r\n\r\n        @Throws(RemoteException::class)\r\n        override fun getClientAcctMgrInfo(): AcctMgrInfo {\r\n            return clientStatus.acctMgrInfo\r\n        }\r\n\r\n        @Throws(RemoteException::class)\r\n        override fun getTransfers(): List<Transfer> {\r\n            return clientStatus.transfers\r\n        }\r\n\r\n        @Throws(RemoteException::class)\r\n        override fun setAutostart(isAutoStart: Boolean) {\r\n            appPreferences.autostart = isAutoStart\r\n        }\r\n\r\n        @Throws(RemoteException::class)\r\n        override fun setShowNotificationForNotices(isShow: Boolean) {\r\n            appPreferences.showNotificationForNotices = isShow\r\n        }\r\n\r\n        @Throws(RemoteException::class)\r\n        override fun getShowAdvanced(): Boolean {\r\n            return appPreferences.showAdvanced\r\n        }\r\n\r\n        @Throws(RemoteException::class)\r\n        override fun getAutostart(): Boolean {\r\n            return appPreferences.autostart\r\n        }\r\n\r\n        @Throws(RemoteException::class)\r\n        override fun getShowNotificationForNotices(): Boolean {\r\n            return appPreferences.showNotificationForNotices\r\n        }\r\n\r\n        @Throws(RemoteException::class)\r\n        override fun getLogLevel(): Int {\r\n            return appPreferences.logLevel\r\n        }\r\n\r\n        @Throws(RemoteException::class)\r\n        override fun setLogLevel(level: Int) {\r\n            appPreferences.logLevel = level\r\n        }\r\n\r\n        @Throws(RemoteException::class)\r\n        override fun setPowerSourceAc(src: Boolean) {\r\n            appPreferences.powerSourceAc = src\r\n        }\r\n\r\n        @Throws(RemoteException::class)\r\n        override fun setPowerSourceUsb(src: Boolean) {\r\n            appPreferences.powerSourceUsb = src\r\n        }\r\n\r\n        @Throws(RemoteException::class)\r\n        override fun setPowerSourceWireless(src: Boolean) {\r\n            appPreferences.powerSourceWireless = src\r\n        }\r\n\r\n        @Throws(RemoteException::class)\r\n        override fun getTasks(): List<Result> {\r\n            return clientStatus.tasks\r\n        }\r\n\r\n        @Throws(RemoteException::class)\r\n        override fun getProjectStatus(url: String): String {\r\n            return clientStatus.getProjectStatus(url)\r\n        }\r\n\r\n        @Throws(RemoteException::class)\r\n        override fun getRssNotices(): List<Notice> {\r\n            return clientStatus.rssNotices\r\n        }\r\n\r\n        @Throws(RemoteException::class)\r\n        override fun getSlideshowForProject(url: String): List<ImageWrapper> {\r\n            return clientStatus.getSlideshowForProject(url)\r\n        }\r\n\r\n        @Throws(RemoteException::class)\r\n        override fun getStationaryDeviceMode(): Boolean {\r\n            return appPreferences.stationaryDeviceMode\r\n        }\r\n\r\n        @Throws(RemoteException::class)\r\n        override fun getPowerSourceAc(): Boolean {\r\n            return appPreferences.powerSourceAc\r\n        }\r\n\r\n        @Throws(RemoteException::class)\r\n        override fun getPowerSourceUsb(): Boolean {\r\n            return appPreferences.powerSourceUsb\r\n        }\r\n\r\n        @Throws(RemoteException::class)\r\n        override fun getPowerSourceWireless(): Boolean {\r\n            return appPreferences.powerSourceWireless\r\n        }\r\n\r\n        @Throws(RemoteException::class)\r\n        override fun setShowAdvanced(isShow: Boolean) {\r\n            appPreferences.showAdvanced = isShow\r\n        }\r\n\r\n        @Throws(RemoteException::class)\r\n        override fun setStationaryDeviceMode(mode: Boolean) {\r\n            appPreferences.stationaryDeviceMode = mode\r\n        }\r\n\r\n        @Throws(RemoteException::class)\r\n        override fun getProjectIconByName(name: String): Bitmap? {\r\n            return clientStatus.getProjectIconByName(name)\r\n        }\r\n\r\n        @Throws(RemoteException::class)\r\n        override fun getProjectIcon(id: String): Bitmap? {\r\n            return clientStatus.getProjectIcon(id)\r\n        }\r\n\r\n        @Throws(RemoteException::class)\r\n        override fun getSuspendWhenScreenOn(): Boolean {\r\n            return appPreferences.suspendWhenScreenOn\r\n        }\r\n\r\n        @Throws(RemoteException::class)\r\n        override fun setSuspendWhenScreenOn(swso: Boolean) {\r\n            appPreferences.suspendWhenScreenOn = swso\r\n        }\r\n\r\n        @Throws(RemoteException::class)\r\n        override fun getCurrentStatusTitle(): String {\r\n            return clientStatus.currentStatusTitle\r\n        }\r\n\r\n        @Throws(RemoteException::class)\r\n        override fun getCurrentStatusDescription(): String {\r\n            return clientStatus.currentStatusDescription\r\n        }\r\n\r\n        @Throws(RemoteException::class)\r\n        override fun cancelNoticeNotification() {\r\n            noticeNotification.cancelNotification()\r\n        }\r\n\r\n        @Throws(RemoteException::class)\r\n        override fun runBenchmarks(): Boolean {\r\n            return clientInterface.runBenchmarks()\r\n        }\r\n\r\n        @Throws(RemoteException::class)\r\n        override fun getProjectInfo(url: String): ProjectInfo {\r\n            return clientInterface.getProjectInfo(url)\r\n        }\r\n\r\n        @Throws(RemoteException::class)\r\n        override fun boincMutexAcquired(): Boolean {\r\n            return mutex.isAcquired\r\n        }\r\n\r\n    } // --end-- remote service\r\n\r\n    companion object {\r\n        private const val INSTALL_FAILED = \"Failed to install: \"\r\n        private const val IOEXCEPTION_LOG = \"IOException: \"\r\n    }\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- app/src/main/java/edu/berkeley/boinc/client/Monitor.kt	(revision 03a069bbbfaf18692a17d8c5902d99539262591d)
+++ app/src/main/java/edu/berkeley/boinc/client/Monitor.kt	(date 1602782794461)
@@ -18,13 +18,14 @@
  */
 package edu.berkeley.boinc.client
 
+import android.app.AlarmManager
+import android.app.PendingIntent
 import android.app.Service
 import android.content.BroadcastReceiver
 import android.content.Context
 import android.content.Intent
 import android.content.IntentFilter
 import android.graphics.Bitmap
-import android.net.wifi.SupplicantState
 import android.net.wifi.WifiInfo
 import android.net.wifi.WifiManager
 import android.net.wifi.WifiManager.NETWORK_STATE_CHANGED_ACTION
@@ -33,7 +34,6 @@
 import androidx.core.content.getSystemService
 import androidx.lifecycle.LifecycleService
 import androidx.lifecycle.lifecycleScope
-import androidx.localbroadcastmanager.content.LocalBroadcastManager
 import androidx.preference.PreferenceManager
 import edu.berkeley.boinc.BOINCApplication
 import edu.berkeley.boinc.BuildConfig
@@ -250,6 +250,12 @@
         }
     }
 
+    // https://robertohuertas.com/2019/06/29/android_foreground_services/
+    override fun onTaskRemoved(rootIntent: Intent) {
+        super.onTaskRemoved(rootIntent);
+        // closes without calling onDestroy when user selects close all
+    }
+
     override fun onStartCommand(intent: Intent?, flags: Int, startId: Int): Int {
         super.onStartCommand(intent, flags, startId)
         //this gets called after startService(intent) (either by BootReceiver or SplashActivity, depending on the user's autostart configuration)
